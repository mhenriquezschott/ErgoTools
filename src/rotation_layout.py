# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled02.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import sys
import os
import shutil
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm

#import threading
import json
import re

import csv

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib.colors import Normalize
from matplotlib.cm import ScalarMappable

#from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas


from PyQt5.QtWidgets import (QApplication, QDialog, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, QDateEdit,
                             QPushButton, QFrame, QGraphicsView, QGraphicsScene, QToolButton, QCheckBox, QGroupBox, QGridLayout, QStatusBar, QGraphicsPixmapItem, QMenu, QAction, QSpinBox, QGraphicsRectItem, QFileDialog, QProgressBar)
from PyQt5.QtGui import QStandardItemModel, QStandardItem, QPixmap, QCursor, QPen, QIcon, QBrush, QColor, QPolygonF, QFont, QPainter, QFontMetrics, QTransform, QIntValidator
from PyQt5.QtCore import Qt, QDate, QSize, QPointF, QRectF, QTimer, QRect
from PyQt5.QtWidgets import QWidget, QGraphicsItem, QGraphicsEllipseItem, QGraphicsRectItem, QFileDialog, QGraphicsItem, QGraphicsPolygonItem, QGraphicsScene, QGraphicsPixmapItem, QTableWidget, QTableWidgetItem, QStyledItemDelegate
from PyQt5 import QtWidgets, QtCore 

from PyQt5.QtTest import QTest


import datetime
from datetime import datetime
import random
import sqlite3

#from PyQt5.QtGui import QIcon, QPixmap, QFont
#import random
import time
from typing import Dict, List, Sequence



import sys
from PyQt5.QtWidgets import (
    QApplication, QDialog, QVBoxLayout, QHBoxLayout, QGroupBox,
    QLabel, QComboBox, QPushButton, QGraphicsView, QGraphicsScene, QMessageBox, QLineEdit, QDialogButtonBox
)
from PyQt5.QtGui import QPixmap, QIcon, QFont
from PyQt5.QtCore import Qt

from visualworkertool import VisualWorkerTool

from plotviewerdialog import PlotViewerDialog
from multiselectcombobox import MultiSelectComboBox

from zcpwindow import ZCPWindow

import pulp

from optimizedrotation_window import OptimizedRotationWindow
from comparerotation_window import CompareRotationWindow
from compareopallrotation_window import CompareOpAllRotationWindow


from pyLiFFT import LiFFT
from pyDUET import DUET
from pyTST import TST





class ComboBoxDelegate(QStyledItemDelegate):
    def __init__(self, items, table, column_index, parent=None):
        super().__init__(parent)
        self.items = items              # All available job IDs
        self.table = table              # Reference to the rotation table
        self.col = column_index         # The specific column this delegate handles

    def createEditor(self, parent, option, index):
        combo = QComboBox(parent)

        # Gather already assigned jobs in this column
        used_jobs = set()
        for row in range(self.table.rowCount()):
            item = self.table.item(row, self.col)
            if item:
                job_id = item.text().split("\n")[0].strip()
                if job_id:
                    used_jobs.add(job_id)

        # Allow the current job to remain selectable
        current_item = self.table.item(index.row(), index.column())
        current_value = ""
        if current_item:
            current_value = current_item.text().split("\n")[0].strip()
            used_jobs.discard(current_value)

        # Filter job options
        available_items = [j for j in self.items if j not in used_jobs or j == current_value]
        combo.addItems(available_items)
        return combo

    def setEditorData(self, editor, index):
        if not index.isValid():
            return
        current = index.data(Qt.EditRole) or index.data(Qt.DisplayRole)
        if current:
            job_id = current.split("\n")[0].strip()
            i = editor.findText(job_id)
            editor.setCurrentIndex(i if i >= 0 else 0)

    def setModelData(self, editor, model, index):
        if editor.currentIndex() >= 0:
            model.setData(index, editor.currentText(), Qt.EditRole)

    def updateEditorGeometry(self, editor, option, index):
        editor.setGeometry(option.rect)
        

class RotationLayoutWindow(QDialog):
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Job Rotation Optimization Tool (JROT)")
        
        #self._save_lock = threading.Lock()

        self.operator_count = 0
        self.initUI()
    
    def initUI(self):
        self.setFixedSize(1720, 940)
        
        
        bold_font = QFont()
        bold_font.setBold(True)
        
        #self.filters_group = QtWidgets.QGroupBox(self)

        
        self.filters_group = QtWidgets.QGroupBox(self)
        self.filters_group.setGeometry(QtCore.QRect(10, 0, 1690, 181))
        self.filters_group.setObjectName("filters_group")
        self.rotationfilter_group = QtWidgets.QGroupBox(self.filters_group)
        self.rotationfilter_group.setGeometry(QtCore.QRect(10, 20, 1670, 61))
        self.rotationfilter_group.setObjectName("rotationfilter_group")
        self.rotationid_label = QtWidgets.QLabel(self.rotationfilter_group)
        self.rotationid_label.setGeometry(QtCore.QRect(10, 30, 67, 17))
        self.rotationid_label.setObjectName("rotationid_label")
        self.rotation_combo = QtWidgets.QComboBox(self.rotationfilter_group)
        self.rotation_combo.setGeometry(QtCore.QRect(80, 27, 171, 25))
        self.rotation_combo.setObjectName("plant_combo")
        self.rotation_combo.setEditable(True)  # This allows user input
                
        self.workersnumber_combo = QtWidgets.QComboBox(self.rotationfilter_group)
        self.workersnumber_combo.setGeometry(QtCore.QRect(354, 27, 151, 25))
        self.workersnumber_combo.setObjectName("workersnumber_combo")
        self.workersnumber_combo.addItems([str(n) for n in (2, 3, 4, 5, 6, 7, 8, 9, 10)])
        
        self.workers_label = QtWidgets.QLabel(self.rotationfilter_group)
        self.workers_label.setGeometry(QtCore.QRect(270, 30, 81, 17))
        self.workers_label.setObjectName("workers_label")
        
        self.timeblocks_combo = QtWidgets.QComboBox(self.rotationfilter_group)
        self.timeblocks_combo.setGeometry(QtCore.QRect(620, 27, 121, 25))
        self.timeblocks_combo.setObjectName("timeblocks_combo")
        self.timeblocks_combo.addItems([str(n) for n in (2, 3, 4, 5, 6, 7, 8, 9, 10)])
        # ← set “4” as the default selection
        self.timeblocks_combo.setCurrentText("4")
        
        
        self.timeblock_label = QtWidgets.QLabel(self.rotationfilter_group)
        self.timeblock_label.setGeometry(QtCore.QRect(530, 30, 91, 17))
        self.timeblock_label.setObjectName("timeblock_label")
        
        self.jobs_label = QtWidgets.QLabel(self.rotationfilter_group)
        self.jobs_label.setGeometry(QtCore.QRect(770, 30, 61, 17))
        self.jobs_label.setObjectName("jobs_label")
        self.jobsnumber_combo = QtWidgets.QComboBox(self.rotationfilter_group)
        self.jobsnumber_combo.setGeometry(QtCore.QRect(830, 27, 141, 25))
        self.jobsnumber_combo.setObjectName("jobsnumber_combo")
        self.jobs_label.hide()
        self.jobsnumber_combo.hide()
        
        # Optimizer Time Limit Label
        self.time_limit_label = QtWidgets.QLabel("Optimizer Time Limit (minutes):", self.rotationfilter_group)
        self.time_limit_label.setGeometry(QtCore.QRect(800, 30, 270, 17))
        self.time_limit_label.setObjectName("time_limit_label")

        # Optimizer Time Limit Input
        self.time_limit_input = QtWidgets.QLineEdit(self.rotationfilter_group)
        self.time_limit_input.setGeometry(QtCore.QRect(1020, 27, 40, 25))
        self.time_limit_input.setValidator(QIntValidator(1, 180))  # Only allow integers between 1 and 180
        self.time_limit_input.setText("1")  # Default to 1 minute
        self.time_limit_input.setAlignment(Qt.AlignCenter)
        self.time_limit_input.setObjectName("time_limit_input")


        
        self.toolfilter_group = QtWidgets.QGroupBox(self.filters_group)
        self.toolfilter_group.setGeometry(QtCore.QRect(10, 80, 191, 91))
        self.toolfilter_group.setObjectName("toolfilter_group")
        self.toolsid_label = QtWidgets.QLabel(self.toolfilter_group)
        self.toolsid_label.setGeometry(QtCore.QRect(10, 30, 67, 17))
        self.toolsid_label.setObjectName("toolsid_label")
        
        self.tool_combo = QtWidgets.QComboBox(self.toolfilter_group)
        self.tool_combo.setGeometry(QtCore.QRect(70, 27, 111, 25))
        self.tool_combo.setObjectName("tool_combo")
        self.tool_combo.currentIndexChanged.connect(self.ontoolComboChanged)

        
        self.clearfilter_button = QtWidgets.QPushButton(self.filters_group)
        self.clearfilter_button.setGeometry(QtCore.QRect(1160, 30, 201, 71))
        self.clearfilter_button.setObjectName("clearfilter_button")
        self.applyfilter_button = QtWidgets.QPushButton(self.filters_group)
        self.applyfilter_button.setGeometry(QtCore.QRect(1160, 100, 201, 71))
        self.applyfilter_button.setObjectName("applyfilter_button")
        # Connect signal
        self.applyfilter_button.clicked.connect(self.applyfilterButtonClicked)
        
        self.clearfilter_button.hide()
        self.applyfilter_button.hide()
        
        
        
        
        
        # Rotation Table
        self.rotation_table = QTableWidget(self)
        self.rotation_table.setGeometry(QtCore.QRect(10, 230, 950, 580))
        self.rotation_table.setObjectName("rotation_table")
   
        self.rotation_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.rotation_table.customContextMenuRequested.connect(self.showContextMenu)
        
       
        tool_name = self.tool_combo.currentText()
        self.label_current_table = QLabel(f"Current {tool_name} Rotation", self)
        self.label_current_table.setGeometry(QtCore.QRect(15, 200, 400, 25))  # x, y, width, height
        font = QFont()
        font.setBold(True)
        self.label_current_table.setFont(font)
 
        self.label_optimized_table = QLabel("Optimized Rotation", self)
        self.label_optimized_table.setGeometry(QtCore.QRect(1000, 200, 400, 25))
        font.setBold(True)
        self.label_optimized_table.setFont(font)
        
   
        # optimized Rotation Table
        self.optimized_table = QTableWidget(self)
        self.optimized_table.setGeometry(QtCore.QRect(1000, 230, 700, 580))
        self.optimized_table.setObjectName("optimized_table")
        
        
        
        
        
        
        
        self.first_button = QPushButton("|<", self)
        self.first_button.setFont(bold_font)
        self.first_button.setGeometry(QtCore.QRect(10, 830, 50, 30))
        self.first_button.clicked.connect(self.firstRotationScheme)
        
        self.previous_button = QPushButton("<", self)
        self.previous_button.setFont(bold_font)
        self.previous_button.setGeometry(QtCore.QRect(65, 830, 50, 30))
        self.previous_button.clicked.connect(self.previousRotationScheme)
        
        self.next_button = QPushButton(">", self)
        self.next_button.setFont(bold_font)
        self.next_button.setGeometry(QtCore.QRect(120, 830, 50, 30))
        self.next_button.clicked.connect(self.nextRotationScheme)
        
        self.last_button = QPushButton(">|", self)
        self.last_button.setFont(bold_font)
        self.last_button.setGeometry(QtCore.QRect(175, 830, 50, 30))
        self.last_button.clicked.connect(self.lastRotationScheme)
        
        self.new_button = QPushButton("New", self)
        self.new_button.setFont(bold_font)
        self.new_button.setGeometry(QtCore.QRect(250, 830, 80, 30))
        self.new_button.clicked.connect(self.newRotationScheme)
        
        self.save_button = QPushButton("Save", self)
        self.save_button.setFont(bold_font)
        self.save_button.setGeometry(QtCore.QRect(335, 830, 80, 30))
        self.save_button.clicked.connect(self.saveRotationScheme)
        
        self.delete_button = QPushButton("Delete", self)
        self.delete_button.setFont(bold_font)
        self.delete_button.setGeometry(QtCore.QRect(420, 830, 80, 30))
        self.delete_button.clicked.connect(self.deleteRotationScheme)
        
        self.search_button = QPushButton("Search", self)
        self.search_button.setFont(bold_font)
        self.search_button.setGeometry(QtCore.QRect(505, 830, 80, 30))
        self.search_button.clicked.connect(self.searchRotationScheme)
        
        self.cancel_button = QPushButton("Cancel", self)
        self.cancel_button.setFont(bold_font)
        self.cancel_button.setGeometry(QtCore.QRect(590, 830, 80, 30))
        self.cancel_button.clicked.connect(self.cancelRotationScheme)
        
        self.close_button = QPushButton("Close", self)
        self.close_button.setFont(bold_font)
        self.close_button.setGeometry(QtCore.QRect(675, 830, 80, 30))
        self.close_button.clicked.connect(self.close)

        
        
        
     
        self.optimize_btn = QPushButton("Optimize", self)
        self.optimize_btn.setFont(bold_font)
        self.optimize_btn.setGeometry(QtCore.QRect(785, 830, 80, 30))
        self.optimize_btn.clicked.connect(self.onOptimizeClicked)
        
        
        self.compare_btn = QPushButton("Compare", self)
        self.compare_btn.setFont(bold_font)
        self.compare_btn.setGeometry(QtCore.QRect(870, 830, 90, 30))
        self.compare_btn.clicked.connect(self.onCompareClicked)
        
        
        
        
        self.optimizeall_btn = QPushButton("Optimize for All", self)
        self.optimizeall_btn.setFont(bold_font)
        self.optimizeall_btn.setGeometry(QtCore.QRect(1000, 830, 140, 30))
        self.optimizeall_btn.clicked.connect(self.onOptimizeAllClicked)
        
        
        
        
        
        self.transfer_button = QPushButton("←", self)  # Or use "⇐", "⟵", etc.
        self.transfer_button.setFont(QFont("Arial", 20, QFont.Bold))
        self.transfer_button.setGeometry(QtCore.QRect(962, 230, 35, 580))
        self.transfer_button.setObjectName("transfer_button")
        self.transfer_button.setToolTip("Copy optimized rotation to current table")
        self.transfer_button.clicked.connect(self.transferOptimizedToCurrent)
        
        
        



        # Disclaimer Label (two lines, right-aligned, bold black)
        self.disclaimer_label = QLabel(self)
        self.disclaimer_label.setText(
            "The Job Rotation Optimization Tool is based on a statistical model using LIFFT, DUET, and The Shoulder Tool.\n"
            "Estimates depend on input data; rotating high-risk jobs may elevate risk for workers in lower-risk jobs."
        )
        self.disclaimer_label.setStyleSheet("font-weight: bold; color: black;")
        self.disclaimer_label.setWordWrap(True)
        self.disclaimer_label.setAlignment(Qt.AlignCenter | Qt.AlignVCenter)
        self.disclaimer_label.setGeometry(QtCore.QRect(310, 880, 1100, 40))  # Adjust position as needed




        
        self.setUIText()
        
        
        if self.parent().projectFileCreated:
            self.loadTools()
            self.loadRotationSchemes()
            
            self.rotation_combo.currentIndexChanged.connect(self.loadRotationDetails)
        
            if self.rotation_combo.count() > 0:
                #self.label_current_table.setText(f"Current {self.tool_combo.currentText()} Rotation")

                self.rotation_combo.setCurrentIndex(0)
                self.loadRotationDetails()


 
 
    def setUIText(self):
        _translate = QtCore.QCoreApplication.translate
        self.filters_group.setTitle("Filters")
        self.rotationfilter_group.setTitle("Rotation")
        self.rotationid_label.setText("<html><head/><body><p>Rotation:</p></body></html>")
        self.workers_label.setText("Workers N°:D:")
        self.timeblock_label.setText("Time Blocks:")
        self.jobs_label.setText("Jobs N°:")
        self.toolfilter_group.setTitle("Tool")
        self.toolsid_label.setText("Tool ID:")
        self.clearfilter_button.setText("Clear")
        self.applyfilter_button.setText("Apply")



    def createImageButton(self, parent, image_path, geometry, icon_size=(32, 32)):
        button = QtWidgets.QPushButton(parent)
        button.setGeometry(geometry)
        button.setIcon(QIcon(image_path))
        button.setIconSize(QtCore.QSize(*icon_size))  # Set the size of the icon
        return button
    

    def ontoolComboChanged(self, index):
        self.loadRotationDetails()


    def applyfilterButtonClicked(self):
        n_workers = int(self.workersnumber_combo.currentText())
        n_blocks = int(self.timeblocks_combo.currentText())
        tool_id = self.tool_combo.currentText()
    
        # Get data from database
        worker_data = self.getWorkers()
        job_data = self.getJobsWithMeasurement(tool_id)
    
        worker_pool = [w["id"] for w in worker_data]
        worker_tooltips = {w["id"]: f"{w['first_name']} {w['last_name']}" for w in worker_data}
    
        job_pool = [j["id"] for j in job_data]
  
        job_info = {
            j["id"]: {
                "prob": j["probability_outcome"],
                "color": j["color"],
                "name": j["name"],
                "damage": j["total_cumulative_damage"],
                "tool": j["tool_id"]
            } for j in job_data
        }

        # Delegate rendering to new method
        self.renderEmptyRotationTable(
            n_workers=n_workers,
            n_blocks=n_blocks,
            worker_pool=worker_pool,
            worker_tooltips=worker_tooltips,
            job_pool=job_pool,
            job_info=job_info
        )





    def renderEmptyRotationTable(self, n_workers, n_blocks, worker_pool, worker_tooltips, job_pool, job_info):
        table = self.rotation_table
        table.clear()
        table.setRowCount(n_workers)
        table.setColumnCount(1 + n_blocks)
    
        # Set row height
        table.verticalHeader().setDefaultSectionSize(60)
    
        # Set headers
        #headers = ["Worker"] + [f"Time-Block\n{i + 1}" for i in range(n_blocks)] + ["Avg.", "Suggestion"]
        headers = ["Worker"] + [f"Time-Block\n{i + 1}" for i in range(n_blocks)] + ["Avg.", "Recommendation"]
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.horizontalHeader().setDefaultAlignment(Qt.AlignCenter)
    
        header = table.horizontalHeader()
        font = header.font()
        font.setBold(True)
        header.setFont(font)

        
    
        # Fixed width for known columns
        worker_col_width = 80
        time_block_col_width = 100
        avg_col_width = 100
        table_total_width = 950  # Width of the QTableWidget
        
        # Compute how much is left for the Suggestion column
        n_timeblocks = n_blocks
        suggestion_col_index = n_timeblocks + 2
        
        fixed_columns_total = worker_col_width + (time_block_col_width * n_timeblocks) + avg_col_width
        suggestion_col_width = max(150, table_total_width - fixed_columns_total)
        
        # Apply column widths
        table.setColumnWidth(0, worker_col_width)  # Worker
        for col in range(1, n_timeblocks + 1):
            table.setColumnWidth(col, time_block_col_width)  # Time-Block columns
        table.setColumnWidth(n_timeblocks + 1, avg_col_width)  # Avg
        table.setColumnWidth(suggestion_col_index, suggestion_col_width)  # Suggestion
            
    
    
    
    
        # Fill with empty cells
        for row in range(n_workers):
            table.setItem(row, 0, QTableWidgetItem(""))  # Worker
            for col in range(1, n_blocks + 1):
                table.setItem(row, col, QTableWidgetItem(""))  # Job
            table.setItem(row, n_blocks + 1, QTableWidgetItem(""))  # Avg.
            table.setItem(row, n_blocks + 2, QTableWidgetItem(""))  # Suggestion

        # Set combo delegates
        table.setItemDelegateForColumn(0, ComboBoxDelegate(worker_pool, table, 0, table))
        for col in range(1, n_blocks + 1):
            table.setItemDelegateForColumn(col, ComboBoxDelegate(job_pool, table, col, table))
    
        # Disconnect and reconnect signals to avoid loops
        try:
            table.cellChanged.disconnect()
        except:
            pass
        table.cellChanged.connect(self.handleCellChanged)
 

 
    def loadTools(self):
        """
        Loads all ergonomic tools into the tool_combo combobox.
        """
        # Retrieve the full dataset
        self.ergotool_dataset = self.getTools()
    
        # Suspend signals while updating the combobox
        self.tool_combo.blockSignals(True)
    
        # Clear existing items and populate the combobox with tool IDs
        self.tool_combo.clear()
        tool_ids = [row["id"] for row in self.ergotool_dataset]
        self.tool_combo.addItems(tool_ids)
    
        # Set "LiFFT" as the default selection if available
        if "LiFFT" in tool_ids:
            self.tool_combo.setCurrentText("LiFFT")
    
        # Restore signals
        self.tool_combo.blockSignals(False)
    
    
    def getTools(self):
        """
        Retrieves all records from the ErgoTool table.
    
        Returns:
            list: A list of dictionaries containing tool data.
        """
        if not self.parent().projectFileCreated or not self.parent().projectdatabasePath:
            QMessageBox.warning(self, "Error", "No project file loaded or saved.")
            return []
    
        # Query to retrieve all tool records
        query = """
            SELECT id, name, description, authors
            FROM ErgoTool
            ORDER BY id
        """
    
        try:
            # Connect to the database and execute query
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            conn.row_factory = sqlite3.Row  # Dictionary-like access
            cursor = conn.cursor()
            cursor.execute(query)
            tools = cursor.fetchall()
            conn.close()
    
            # Convert results to a list of dictionaries
            return [dict(row) for row in tools]
    
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to retrieve ergonomic tools:\n{str(e)}")
            return []


    def getRotationSchemes(self):
        """
        Retrieves all rotation scheme IDs from the RotationScheme table.
        Returns:
            list: A list of rotation scheme IDs.
        """
        if not self.parent().projectFileCreated or not self.parent().projectdatabasePath:
            QMessageBox.warning(self, "Error", "No project file loaded or saved.")
            return []
    
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM RotationScheme ORDER BY id")
            rows = cursor.fetchall()
            return [row[0] for row in rows]
        except Exception as e:
            QMessageBox.critical(self, "Database Error", f"Failed to retrieve rotation schemes:\n{str(e)}")
            return []
        finally:
            conn.close()


    def loadRotationSchemes(self):
        """
        Loads all rotation schemes into the rotation_combo box.
        """
        schemes = self.getRotationSchemes()
        self.rotation_combo.blockSignals(True)
        self.rotation_combo.clear()
        self.rotation_combo.addItems(schemes)
        self.rotation_combo.setCurrentIndex(-1)  # No selection by default
        self.rotation_combo.blockSignals(False)


    def firstRotationScheme(self):
        if self.rotation_combo.count() > 0:
            self.rotation_combo.setCurrentIndex(0)
    
    def previousRotationScheme(self):
        current_index = self.rotation_combo.currentIndex()
        if current_index > 0:
            self.rotation_combo.setCurrentIndex(current_index - 1)

    def nextRotationScheme(self):
        current_index = self.rotation_combo.currentIndex()
        if current_index < self.rotation_combo.count() - 1:
            self.rotation_combo.setCurrentIndex(current_index + 1)

    def lastRotationScheme(self):
        if self.rotation_combo.count() > 0:
            self.rotation_combo.setCurrentIndex(self.rotation_combo.count() - 1)

    def newRotationScheme(self):
        self.newRotation()

    def saveRotationScheme(self):
        self.saveRotationScheme()
        
    def deleteRotationScheme(self):
        self.deleteRotation()
    
    def searchRotationScheme(self):
        self.searchRotation()
    
    
    def cancelRotationScheme(self):
        self.cancelRotation()



    def getWorkers(self):
        """
        Retrieves all workers from the Worker table.
        """
        if not self.parent().projectFileCreated or not self.parent().projectdatabasePath:
            return []
    
        query = """
            SELECT id, first_name, last_name
            FROM Worker
            ORDER BY id
        """
    
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            cursor.execute(query)
            results = cursor.fetchall()
            return [dict(row) for row in results]
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Error loading workers:\n{str(e)}")
            return []

    
    def getJobsWithMeasurement(self, tool_id):
        """
        Retrieves jobs and their measurement values for a specific ergonomic tool.
        """
        if not self.parent().projectFileCreated or not self.parent().projectdatabasePath:
            return []
    
    
        query = """
            SELECT j.id, j.name, jm.probability_outcome, jm.total_cumulative_damage, jm.color, jm.tool_id
            FROM Job j
            JOIN JobMeasurement jm ON j.id = jm.job_id
            WHERE jm.tool_id = ?
            ORDER BY j.id
        """
    
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            cursor.execute(query, (tool_id,))
            results = cursor.fetchall()
            return [dict(row) for row in results]
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Error loading job data:\n{str(e)}")
            return []





    def saveRotationScheme(self):
        """
        Saves or updates a rotation scheme and its assignments to the database.
        """
        if not self.parent().projectFileCreated:
            QMessageBox.warning(self, "Error", "No project file has been created or loaded. Please create or load a project before saving.")
            return
    
        if not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.critical(self, "Error", "Database path is not set. Unable to save rotation.")
            return
    
        rotation_id = self.rotation_combo.currentText().strip()
        if not rotation_id:
            QMessageBox.warning(self, "Validation Error", "Rotation ID is required.")
            return
    
        # TODO: Replace with actual UI control (e.g., QLineEdit) for scheme name
        # TODO: Add description field to the db?
        scheme_name = "Unnamed Scheme"
    
        plant_name = self.parent().plant_combo.currentText()
        shift_id = self.parent().shift_combo.currentText()
    
        table = self.rotation_table
        n_workers = table.rowCount()
        n_blocks = table.columnCount() - 3  # Exclude Worker, Avg, Suggestion columns
    
        # Collect used jobs
        used_jobs = set()
        for row in range(n_workers):
            for col in range(1, n_blocks + 1):
                item = table.item(row, col)
                if item:
                    job_id = item.text().split("\n")[0].strip()
                    if job_id:
                        used_jobs.add(job_id)
        n_jobs = len(used_jobs)
    
        database_path = self.parent().projectdatabasePath
        conn = sqlite3.connect(database_path)
        cursor = conn.cursor()
    
        try:
            # Insert or update scheme
            cursor.execute('''
                INSERT INTO RotationScheme (id, name, plant_name, shift_id, num_workers, num_timeblocks, num_jobs)
                VALUES (?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(id) DO UPDATE SET
                    name = excluded.name,
                    plant_name = excluded.plant_name,
                    shift_id = excluded.shift_id,
                    num_workers = excluded.num_workers,
                    num_timeblocks = excluded.num_timeblocks,
                    num_jobs = excluded.num_jobs
            ''', (rotation_id, scheme_name, plant_name, shift_id, n_workers, n_blocks, n_jobs))
    
            # Delete old assignments for this scheme
            cursor.execute("DELETE FROM RotationAssignment WHERE scheme_id = ?", (rotation_id,))
    
            # Insert new assignments from table
            for row in range(n_workers):
                worker_item = table.item(row, 0)
                if not worker_item:
                    continue
                worker_id = worker_item.text().strip()
                if not worker_id:
                    continue

                for block in range(n_blocks):
                    col = block + 1
                    job_item = table.item(row, col)
                    if not job_item:
                        continue
                    job_id = job_item.text().split("\n")[0].strip()
                    if not job_id:
                        continue
    
                    cursor.execute('''
                        INSERT INTO RotationAssignment (scheme_id, block_index, worker_id, job_id)
                        VALUES (?, ?, ?, ?)
                    ''', (rotation_id, block, worker_id, job_id))
    
            conn.commit()
    
            QMessageBox.information(self, "Success", f"Rotation scheme '{rotation_id}' has been saved successfully.")

            self.loadRotationSchemes()
            index = self.rotation_combo.findText(rotation_id)
            if index != -1:
                self.rotation_combo.setCurrentIndex(index)
    
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Database Error", f"An error occurred while saving the rotation:\n{str(e)}")
    
        finally:
        
            # Enable navigation and management buttons
            self.first_button.setEnabled(True)
            self.previous_button.setEnabled(True)
            self.next_button.setEnabled(True)
            self.last_button.setEnabled(True)
            self.delete_button.setEnabled(True)
            self.search_button.setEnabled(True)
            self.optimize_btn.setEnabled(True)
            self.compare_btn.setEnabled(True)
        
            conn.close()




    def loadRotationDetails(self):
        """
        Loads the rotation scheme and its assignments from the database
        based on the selected rotation ID in the combo box.
        """
        rotation_id = self.rotation_combo.currentText().strip()
    
        if not self.parent().projectFileCreated:
            QMessageBox.warning(self, "Error", "No project file has been created or loaded.")
            return
    
        if not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.critical(self, "Error", "Database path is not set.")
            return
    
        if not rotation_id:
            return
    
    
    
        # Get required context keys from parent UI
        plant_name = self.parent().plant_combo.currentText().strip()
        shift_id = self.parent().shift_combo.currentText().strip()
        
        # --- Load scheme metadata fields from database ---
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            cursor = conn.cursor()
        
            
            cursor.execute('''
                SELECT name
                FROM RotationScheme
                WHERE id = ? AND plant_name = ? AND shift_id = ?
            ''', (rotation_id, plant_name, shift_id))
            
            
            scheme_info = cursor.fetchone()
            if scheme_info:
                #scheme_name, description = scheme_info
                scheme_name = scheme_info
        
                # TODO: set these values into the corresponding UI fields when available
                # self.rotation_name_input.setText(scheme_name)
                # self.rotation_description_input.setPlainText(description)
        
        finally:
            conn.close()
    
    
    
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            cursor = conn.cursor()
    
            # Get scheme metadata
            cursor.execute('''
                SELECT num_workers, num_timeblocks
                FROM RotationScheme
                WHERE id = ?
            ''', (rotation_id,))
            row = cursor.fetchone()
            if not row:
                QMessageBox.warning(self, "Error", f"No scheme found for ID: {rotation_id}")
                return
    
            num_workers, num_blocks = row
    
           
            # Set UI controls
            self.workersnumber_combo.setCurrentText(str(num_workers))
            self.timeblocks_combo.setCurrentText(str(num_blocks))
            
            # Prepare data 
            worker_data = self.getWorkers()
            worker_pool = [w["id"] for w in worker_data]
            worker_tooltips = {w["id"]: f"{w['first_name']} {w['last_name']}" for w in worker_data}
            tool_id = self.tool_combo.currentText()
            
            job_data = self.getJobsWithMeasurement(tool_id)
            job_pool = [j["id"] for j in job_data]
            job_info = {
                j["id"]: {
                    "prob": j["probability_outcome"],
                    "color": j["color"],
                    "name": j["name"],
                    "damage": j["total_cumulative_damage"],
                    "tool": j["tool_id"]
                } for j in job_data
            }
            
            # Call rendering function 
            self.renderEmptyRotationTable(
                n_workers=num_workers,
                n_blocks=num_blocks,
                worker_pool=worker_pool,
                worker_tooltips=worker_tooltips,
                job_pool=job_pool,
                job_info=job_info
            )
    
    
            # Get job and worker info for tooltips
            tool_id = self.tool_combo.currentText()
            workers = {w["id"]: f"{w['first_name']} {w['last_name']}" for w in self.getWorkers()}
            
            job_info = {
                j["id"]: {
                    "prob": j["probability_outcome"],
                    "color": j["color"],
                    "name": j["name"],
                    "damage": j["total_cumulative_damage"],
                    "tool": j["tool_id"]
                } for j in self.getJobsWithMeasurement(tool_id)
            }  
    
            table = self.rotation_table
    
            # Clear current change handler to avoid recursive triggering
            try:
                table.cellChanged.disconnect()
            except:
                pass

            # Get assignments
            cursor.execute('''
                SELECT worker_id, block_index, job_id
                FROM RotationAssignment
                WHERE scheme_id = ?
            ''', (rotation_id,))
            assignments = cursor.fetchall()
    
            from collections import defaultdict
            grid = defaultdict(dict)
            for worker_id, block_index, job_id in assignments:
                grid[worker_id][block_index] = job_id
    
            # Fill table row-by-row
            worker_ids = list(grid.keys())
            for row_idx, worker_id in enumerate(worker_ids):
                # Set worker ID
                worker_item = QTableWidgetItem(worker_id)
                worker_item.setToolTip(workers.get(worker_id, ""))
                table.setItem(row_idx, 0, worker_item)

                probs = []
                colors = []
    
                for block in range(num_blocks):
                    col = block + 1
                    job_id = grid[worker_id].get(block)
                    if job_id:
                        job = job_info.get(job_id)
                        item = QTableWidgetItem()
                        if job:
                            formatted_text = f"{job_id}\n{job['prob']}%"
                            item.setText(formatted_text)
                            item.setBackground(QColor(job["color"]))
                            item.setTextAlignment(Qt.AlignCenter)
                            item.setToolTip(f"{job['tool']} – {job['name']} ({job['damage']})")
                        
                            probs.append(job["prob"])
                            c = QColor(job["color"])
                            colors.append((c.red(), c.green(), c.blue()))
                        else:
                            # Show raw job_id if metadata is missing
                            item.setText(job_id)
                            item.setTextAlignment(Qt.AlignCenter)
                        table.setItem(row_idx, col, item)
                    else:
                        table.setItem(row_idx, col, QTableWidgetItem(""))
    

                # Avg column
                if probs:
                    avg_val = round(sum(probs) / len(probs), 1)
                    avg_item = QTableWidgetItem(f"{avg_val}%")
                    avg_item.setTextAlignment(Qt.AlignCenter)
                    if colors:
                        r_avg = sum(c[0] for c in colors) // len(colors)
                        g_avg = sum(c[1] for c in colors) // len(colors)
                        b_avg = sum(c[2] for c in colors) // len(colors)
                        avg_item.setBackground(QColor(r_avg, g_avg, b_avg))
                    table.setItem(row_idx, num_blocks + 1, avg_item)
    
                    # Suggestion column
                    suggestion = self.generateSuggestion(probs)
        
        
                    suggestion_item = QTableWidgetItem(suggestion)
                    suggestion_item.setTextAlignment(Qt.AlignLeft)
                    table.setItem(row_idx, num_blocks + 2, suggestion_item)



            # Re-assign combo delegates after table fill
            table.setItemDelegateForColumn(0, ComboBoxDelegate(list(workers.keys()), table, 0, table))
            for col in range(1, num_blocks + 1):
                table.setItemDelegateForColumn(col, ComboBoxDelegate(list(job_info.keys()), table, col, table))


            
            # Avoid multiple bindings
            try:
                table.cellChanged.disconnect()
            except:
                pass
            table.cellChanged.connect(self.handleCellChanged)
        
    
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to load rotation details:\n{str(e)}")
    
        finally:
            conn.close()
            self.clearOptimizedTable()
            self.label_current_table.setText(f"Current {self.tool_combo.currentText()} Rotation")


    def handleCellChanged(self, row, col):
        #print(f"Recalculating row {row} due to change in column {col}")
        
        table = self.rotation_table
        n_cols = table.columnCount()
    
        try:
            table.cellChanged.disconnect()
        except:
            pass
    
        try:
            tool_id = self.tool_combo.currentText()
            job_data = self.getJobsWithMeasurement(tool_id)
    
            job_info = {
                j["id"]: {
                    "prob": j["probability_outcome"],
                    "color": j["color"],
                    "name": j.get("name", ""),
                    "tool": j.get("tool_id", ""),
                    "damage": j.get("total_cumulative_damage", "")
                } for j in job_data
            }

            probabilities = []
            colors = []
    
            for c in range(1, n_cols - 2):  # Skip worker name, Avg., Suggestion
                item = table.item(row, c)
                if not item:
                    continue
                job_id = item.text().split("\n")[0].strip()
                job = job_info.get(job_id)
                if job:
                    # Reapply cell format
                    item.setText(f"{job_id}\n{job['prob']}%")
                    item.setBackground(QColor(job["color"]))
                    item.setTextAlignment(Qt.AlignCenter)
                    item.setToolTip(f"{job['tool']} – {job['name']} ({job['damage']})")
    
                    probabilities.append(job["prob"])
                    color = QColor(job["color"])
                    colors.append((color.red(), color.green(), color.blue()))
    
            # Avg column
            if probabilities:
                avg_val = round(sum(probabilities) / len(probabilities), 1)
                avg_item = QTableWidgetItem(f"{avg_val}%")
                avg_item.setTextAlignment(Qt.AlignCenter)
    
                if colors:
                    r = sum(c[0] for c in colors) // len(colors)
                    g = sum(c[1] for c in colors) // len(colors)
                    b = sum(c[2] for c in colors) // len(colors)
                    avg_item.setBackground(QColor(r, g, b))
    
                table.setItem(row, n_cols - 2, avg_item)
    
                # Suggestion
                suggestion_item = QTableWidgetItem(self.generateSuggestion(probabilities))
                suggestion_item.setTextAlignment(Qt.AlignLeft)
                table.setItem(row, n_cols - 1, suggestion_item)
    
        finally:
            table.cellChanged.connect(self.handleCellChanged)


    def generateSuggestion(self, probs):
        if not probs:
            return ""
        high = [p for p in probs if p > 60]
        low = [p for p in probs if p < 20]
        avg = sum(probs) / len(probs)
    
        if len(high) >= 2 and len(low) >= 1:
            return ("Redesign the high-risk jobs as the job rotation scheme is not safe.")
        elif avg > 50:
            return ("Redesign at least one high-risk job, as the job rotation scheme is high-risk.")
        elif 25 <= avg <= 50:
            return ("The job rotation scheme could be improved by redesigning the highest-risk job "
                    "or adding more options for low-risk jobs.")
        elif avg < 25:
            return ("This job rotation appears to be low risk.")
        return "Assignment is balanced."


        
    
    
    def generateSuggestionOldWorking(self, probs):
        if not probs:
            return ""
        high = [p for p in probs if p > 60]
        low = [p for p in probs if p < 20]
        avg = sum(probs) / len(probs)
        if len(high) >= 2 and len(low) >= 1:
            return "Avoid assigning multiple high-risk jobs"
        elif avg > 50:
            return "Consider adding safer tasks"
        elif max(probs) - min(probs) > 50:
            return "Balance task difficulty"
        elif avg < 25:
            return "This is a safe rotation"
        return "Assignment is balanced"


    def handleContextMenu(self, pos):
        table = self.rotation_table
        index = table.indexAt(pos)
        if not index.isValid():
            return
    
        row, col = index.row(), index.column()
        if col == 0 or col >= table.columnCount() - 2:
            return  # Do not allow delete on worker name, avg or suggestion
    
        menu = QMenu(self)
        delete_action = QAction("Remove Job", self)
        menu.addAction(delete_action)
    
        def remove_job():
            table.setItem(row, col, QTableWidgetItem(""))
            self.handleCellChanged(row, col)
    
        delete_action.triggered.connect(remove_job)
        menu.exec_(table.viewport().mapToGlobal(pos))
    
    def showContextMenu(self, position):
        index = self.rotation_table.indexAt(position)
        if not index.isValid():
            return

        col = index.column()
        if col >= self.rotation_table.columnCount() - 2:
            return  # Skip Avg. and Suggestion columns
    
        menu = QMenu()
        delete_action = QAction("Clear Cell", self)
        delete_action.triggered.connect(lambda: self.clearTableCell(index.row(), col))
        menu.addAction(delete_action)
        menu.exec_(self.rotation_table.viewport().mapToGlobal(position))

    def clearTableCell(self, row, col):
        item = self.rotation_table.item(row, col)
        if item:
            self.rotation_table.blockSignals(True)
            self.rotation_table.setItem(row, col, QTableWidgetItem(""))
            self.rotation_table.blockSignals(False)
            self.handleCellChanged(row, col)  # Ensure recalculation

    
    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Delete:
            selected_items = self.rotation_table.selectedItems()
            for item in selected_items:
                row, col = item.row(), item.column()
                if col >= self.rotation_table.columnCount() - 2:
                    continue  # Skip Avg. and Suggestion
                self.clearTableCell(row, col)
            event.accept()
        else:
            super().keyPressEvent(event)
        
    def newRotation(self):
        """
        Prepares the Rotation Layout Window for entering a new rotation.
        Clears the table and resets the UI for a fresh rotation definition.
        """
        if not self.parent().projectFileCreated:
            QMessageBox.warning(self, "Error", "No project file has been created or loaded.")
            return
    
        if not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.critical(self, "Error", "Database path is not set.")
            return
    
        
         # Enable navigation and management buttons
        self.first_button.setEnabled(False)
        self.previous_button.setEnabled(False)
        self.next_button.setEnabled(False)
        self.last_button.setEnabled(False)
        self.delete_button.setEnabled(False)
        self.search_button.setEnabled(False)
        self.optimize_btn.setEnabled(False)
        self.compare_btn.setEnabled(False)
        
        # Clear rotation ID selection
        self.rotation_combo.blockSignals(True)
        self.rotation_combo.setCurrentIndex(-1)
        self.rotation_combo.setEditText("")
        self.rotation_combo.blockSignals(False)
    
        # Clear associated metadata fields (when available)
        # self.rotation_name_input.clear()
        # self.rotation_description_input.clear()

        # Redraw table using current number of workers and time blocks
        #self.applyfilterButtonClicked()
    
        # Redraw table using current number of workers and time blocks
        n_workers = int(self.workersnumber_combo.currentText())
        n_blocks = int(self.timeblocks_combo.currentText())
        tool_id = self.tool_combo.currentText()
    
        worker_data = self.getWorkers()
        job_data = self.getJobsWithMeasurement(tool_id)
    
        worker_pool = [w["id"] for w in worker_data]
        worker_tooltips = {w["id"]: f"{w['first_name']} {w['last_name']}" for w in worker_data}
        job_pool = [j["id"] for j in job_data]
        job_info = {
            j["id"]: {
                "prob": j["probability_outcome"],
                "color": j["color"],
                "name": j["name"],
                "damage": j["total_cumulative_damage"],
                "tool": j["tool_id"]
            } for j in job_data
        }
    
        self.renderEmptyRotationTable(n_workers, n_blocks, worker_pool, worker_tooltips, job_pool, job_info)

        # Optionally clear optimized table too
        self.clearOptimizedTable()
    
        # Optional: Reset state tracking if needed (e.g., self.currentRotationId = None)
        


    def cancelRotation(self):
        """
        Handles the Cancel button click event for rotation layout.
        Re-enables navigation/management buttons and reloads the first rotation scheme if available.
        """
        # Enable navigation and management buttons
        self.first_button.setEnabled(True)
        self.previous_button.setEnabled(True)
        self.next_button.setEnabled(True)
        self.last_button.setEnabled(True)
        self.delete_button.setEnabled(True)
        self.search_button.setEnabled(True)
        self.optimize_btn.setEnabled(True)
        self.compare_btn.setEnabled(True)
    
        # Reset the rotation combo box to the first item if available
        if self.rotation_combo.count() > 0:
            self.rotation_combo.setCurrentIndex(0)
            self.loadRotationDetails()

        # Optional: Add any additional cancel/reset logic here
        

    def deleteRotation(self):
        """
        Handles the Delete button click event for the Rotation Layout window.
        Deletes the selected rotation scheme and its related assignments from the database.
        """
        if not self.parent().projectFileCreated:
            QMessageBox.warning(self, "Error", "No project file has been created or loaded. Please create or load a project before deleting rotation schemes.")
            return
    
        if not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.critical(self, "Error", "Database path is not set. Unable to delete rotation scheme.")
            return
    
        # Confirm deletion
        reply = QMessageBox.question(self, "Confirm Deletion", 
                                     "Are you sure you want to delete this rotation scheme?",
                                     QMessageBox.Yes | QMessageBox.No)
        if reply != QMessageBox.Yes:
            return

        # Get selected Rotation Scheme ID
        scheme_id = self.rotation_combo.currentText().strip()
        if not scheme_id:
            QMessageBox.warning(self, "Error", "No rotation scheme selected. Unable to delete.")
            return
    
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            cursor = conn.cursor()
            cursor.execute("PRAGMA foreign_keys = ON;")
    
            # Delete from RotationScheme (RotationAssignment will cascade if FK is set properly)
            cursor.execute("""
                DELETE FROM RotationScheme
                WHERE id = ?
            """, (scheme_id,))
            conn.commit()
    
            if cursor.rowcount == 0:
                QMessageBox.warning(self, "Error", f"Rotation scheme '{scheme_id}' not found in the database.")
            else:
                QMessageBox.information(self, "Success", f"Rotation scheme '{scheme_id}' has been deleted successfully.")

            # Remove from combo box and reset view
            self.rotation_combo.removeItem(self.rotation_combo.currentIndex())
            if self.rotation_combo.count() > 0:
                self.rotation_combo.setCurrentIndex(0)
                self.loadRotationDetails()
            else:
                self.rotation_combo.blockSignals(True)
                self.rotation_combo.setCurrentIndex(-1)
                self.rotation_combo.setEditText("")
                self.rotation_combo.blockSignals(False)
                self.rotation_table.setRowCount(0)
                self.rotation_table.setColumnCount(0)
    
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Database Error", f"An error occurred while deleting the rotation scheme:\n{e}")
    
        finally:
            conn.close()



    def searchRotation(self):
        """
        Handles the Search button click event for the Rotation Layout window.
        Allows the user to search for a rotation scheme by its ID.
        """
        # Validate that the project file and database are created
        if not self.parent().projectFileCreated:
            QMessageBox.warning(self, "Error", "No project file has been created or loaded. Please create or load a project before searching.")
            return
    
        if not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.critical(self, "Error", "Database path is not set. Unable to perform search.")
            return

        # Create the search dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("Search Rotation Scheme")
        dialog.setFixedSize(400, 150)
        layout = QVBoxLayout(dialog)
    
        # Rotation ID Search
        id_layout = QHBoxLayout()
        id_label = QLabel("Search by Rotation ID:")
        id_input = QLineEdit()
        id_layout.addWidget(id_label)
        id_layout.addWidget(id_input)
        layout.addLayout(id_layout)
    
        # Dialog buttons
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        layout.addWidget(button_box)

        def performSearch():
            scheme_id = ""
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            cursor = conn.cursor()
    
            try:
                if id_input.text().strip():
                    cursor.execute("""
                        SELECT id FROM RotationScheme
                        WHERE id = ?
                    """, (id_input.text().strip(),))
                    result = cursor.fetchone()
                    if result:
                        scheme_id = result[0]
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to search rotation scheme:\n{str(e)}")
            finally:
                conn.close()
    
            if scheme_id:
                index = self.rotation_combo.findText(scheme_id)
                if index != -1:
                    self.rotation_combo.setCurrentIndex(index)
                    self.loadRotationDetails()
                else:
                    QMessageBox.warning(self, "Not Found", "Rotation scheme found in database but not in combo box.")
            else:
                QMessageBox.information(self, "No Match", "No rotation scheme found with the given ID.")
    
            dialog.accept()
    
        # Connect buttons
        button_box.accepted.connect(performSearch)
        button_box.rejected.connect(dialog.reject)
    
        dialog.exec_()
















    def extract_rotation_data(self, table, get_job_risks_func, tool_id):
        """
        Extracts rotation table data into a usable format for optimization.
        Returns worker_ids, job list, current assignments, and job risk mapping.
        """
        n_rows = table.rowCount()
        n_cols = table.columnCount()
    
        # Get job risks from DB
        job_data = get_job_risks_func(tool_id)
        job_risk = {j["id"]: j["probability_outcome"] for j in job_data}
        job_list = list(job_risk.keys())
    
        worker_ids = []
        current_assignments = {}
    
        #print("\n=== Job-Specific Risk Table ===")
        for row in range(n_rows):
            worker_item = table.item(row, 0)
            if not worker_item:
                continue
            wid = worker_item.text().strip()
            if not wid:
                continue

            worker_ids.append(wid)
            current_assignments[wid] = []
    
            per_cell_risks = []
            job_risks_dict = {}
    
            for col in range(1, n_cols - 2):  # Skip Worker, Avg, Suggestion
                item = table.item(row, col)
                if not item:
                    continue
                job_id = item.text().split("\n")[0].strip()
                current_assignments[wid].append(job_id)
    
                if job_id in job_risk:
                    risk_val = job_risk[job_id]
                    per_cell_risks.append(risk_val)
                    job_risks_dict[f"{job_id}@{col}"] = risk_val  # for display/debug
    
            avg = round(sum(per_cell_risks) / len(per_cell_risks), 1) if per_cell_risks else 0
            #print(f"{wid}: {job_risks_dict} → Avg: {avg}%")
    
        return worker_ids, job_list, current_assignments, job_risk




    def build_optimization_model(self, worker_ids, job_list, current_assignments, job_risk, num_blocks):
        model = pulp.LpProblem("JobRotationOptimization", pulp.LpMinimize)
        x = pulp.LpVariable.dicts("assign", (worker_ids, range(num_blocks), job_list), cat="Binary")
        max_avg = pulp.LpVariable("max_avg", lowBound=0, cat="Continuous")
    
        # === Objective: Minimize the maximum average risk across all workers ===
        model += max_avg
    
        # === Constraint 1: One job per worker per time block ===
        for w in worker_ids:
            for b in range(num_blocks):
                model += pulp.lpSum([x[w][b][j] for j in job_list]) == 1
    
        # === Constraint 2: Preserve the total number of times each job is used ===
        job_totals = {j: 0 for j in job_list}
        for w in worker_ids:
            for j in current_assignments[w]:
                if j in job_totals:
                    job_totals[j] += 1
    
        for j in job_list:
            model += pulp.lpSum([x[w][b][j] for w in worker_ids for b in range(num_blocks)]) == job_totals[j]

        # === Constraint 3: Worker average risk must be <= max_avg ===
        for w in worker_ids:
            total_risk_expr = pulp.lpSum([x[w][b][j] * job_risk[j] for b in range(num_blocks) for j in job_list])
            model += total_risk_expr <= max_avg * num_blocks + 1e-3
    
        # === OPTIONAL CONSTRAINT: Prevent duplicate job in same time block ===
        # Each job can be assigned at most once in a single time block (column-wise uniqueness)
        # Comment this block to disable the constraint
        for b in range(num_blocks):
            for j in job_list:
                model += pulp.lpSum([x[w][b][j] for w in worker_ids]) <= 1, f"UniqueJob_{j}_Block{b}"
    
        return model, x


   
    def extract_solution(self, model, x, worker_ids, job_risk, num_blocks):
        #import pulp
        #print("\n=== Optimized Rotation (Min-Max Worker Avg) ===")
        optimized = {}
        for w in worker_ids:
            jobs = []
            risks = []
            for b in range(num_blocks):
                for j in job_risk:
                    if pulp.value(x[w][b][j]) == 1:
                        jobs.append(j)
                        risks.append(job_risk[j])
            avg = round(sum(risks) / num_blocks, 1) if risks else 0
            optimized[w] = (jobs, risks, avg)
            #print(f"{w}: {jobs} → Risk: {risks} → Avg: {avg}%")
        return optimized



    def onOptimizeClicked(self):
      
        table = self.rotation_table
        tool_id = self.tool_combo.currentText()
        num_blocks = int(self.timeblocks_combo.currentText())
    
   

        # Step 5: Get full job metadata for rendering
        job_data = self.getJobsWithMeasurement(tool_id)
        job_info = {
            j["id"]: {
                "prob": j["probability_outcome"],
                "color": j["color"],
                "name": j.get("name", ""),
                "tool": j.get("tool_id", ""),
                "damage": j.get("total_cumulative_damage", "")
            } for j in job_data
        }



        # Show animated overlay
        self.overlay = Overlay(parent=self, message="Optimizing Rotation") #Overlay(parent=self)
        self.overlay.setCancelHandler(self.cancelOptimization)
        seconds = self.getTimeLimitInSeconds()
        self.overlay.start(duration_seconds=seconds)
        #self.overlay.start()
     
     
        
        # Setup thread and worker
        self.optimization_thread = QtCore.QThread()
        self.optimizer_worker = OptimizationWorker(
            table=self.rotation_table,
            tool_id=tool_id,
            num_blocks=num_blocks,
            parent=None  # must not parent to the main thread!
        )
    
    
        self.optimizer_worker.moveToThread(self.optimization_thread)

        self.optimization_thread.started.connect(self.optimizer_worker.run)
        self.optimizer_worker.optimizationCompleted.connect(self.handleOptimizationResult)
        self.optimizer_worker.optimizationCompleted.connect(self.optimization_thread.quit)
        self.optimizer_worker.optimizationCompleted.connect(self.optimizer_worker.deleteLater)
        self.optimization_thread.finished.connect(self.optimization_thread.deleteLater)

        self.optimization_thread.start()
        
    
     




    def onOptimizeClickedOldWorkingNoThreads(self):
        print("\n=== Optimizing Rotation ===")

        table = self.rotation_table
        tool_id = self.tool_combo.currentText()
        num_blocks = int(self.timeblocks_combo.currentText())
    
        # Step 1: Extract data
        worker_ids, job_list, current_assignments, job_risk = self.extract_rotation_data(
            table=table,
            get_job_risks_func=self.getJobsWithMeasurement,
            tool_id=tool_id
        )
    
        # Step 2: Build model
        model, x = self.build_optimization_model(
            worker_ids, job_list, current_assignments, job_risk, num_blocks
        )
    
        # Step 3: Solve
        #model.solve()
        #model.solve(pulp.PULP_CBC_CMD(msg=0))
        #model.solve(pulp.PULP_CBC_CMD(msg=0, timeLimit=10))  # or 10 seconds
        time_limit = self.getTimeLimitInSeconds()
        status = model.solve(pulp.PULP_CBC_CMD(msg=0, timeLimit=time_limit))
        print("Solver status:", pulp.LpStatus[status])

    

        # Step 4: Extract solution into dictionary
        optimized_result = self.extract_solution(
            model=model,
            x=x,
            worker_ids=worker_ids,
            job_risk=job_risk,
            num_blocks=num_blocks
        )
    
        print("=== Optimization Completed ===\n")


        # Step 5: Get full job metadata for rendering
        job_data = self.getJobsWithMeasurement(tool_id)
        job_info = {
            j["id"]: {
                "prob": j["probability_outcome"],
                "color": j["color"],
                "name": j.get("name", ""),
                "tool": j.get("tool_id", ""),
                "damage": j.get("total_cumulative_damage", "")
            } for j in job_data
        }


        
        
        # Step 6: Display the result in the optimized table (right side)
        self.displayOptimizedTable(
            optimized_result=optimized_result,
            job_info=job_info,
            table=self.optimized_table
        )
       

    


    def handleOptimizationError(self, error_msg):
        self.overlay.stop()
        QMessageBox.critical(self, "Optimization Failed", f"An error occurred:\n{error_msg}")
    
    
    def handleOptimizationResult(self, optimized_result):
        self.overlay.stop()
    
        tool_id = self.tool_combo.currentText()
        job_data = self.getJobsWithMeasurement(tool_id)
        job_info = {
            j["id"]: {
                "prob": j["probability_outcome"],
                "color": j["color"],
                "name": j.get("name", ""),
                "tool": j.get("tool_id", ""),
                "damage": j.get("total_cumulative_damage", "")
            } for j in job_data
        }

        self.displayOptimizedTable(optimized_result, job_info, self.optimized_table)
        #print("=== Optimization Completed ===\n")

    
    
    
    def getJobInfoDict(self, tool_id):
        job_data = self.getJobsWithMeasurement(tool_id)
        return {
        j["id"]: {
            "prob": j["probability_outcome"],
            "color": j["color"],
            "name": j.get("name", ""),
            "tool": j.get("tool_id", ""),
            "damage": j.get("total_cumulative_damage", "")
        } for j in job_data
    }



    def displayOptimizedTable(self, optimized_result, job_info, table):
        """
        Populates the optimized_table (QTableWidget) with the result.
        """
        worker_ids = list(optimized_result.keys())
        num_workers = len(worker_ids)
        num_blocks = len(optimized_result[worker_ids[0]][0]) if num_workers else 0
    
        table.clear()
        table.setRowCount(num_workers)
        table.setColumnCount(num_blocks + 2)  # Worker + time blocks + Avg.
    
        # Set headers
        headers = ["Worker"] + [f"Time-Block\n{i + 1}" for i in range(num_blocks)] + ["Avg."]
        table.setHorizontalHeaderLabels(headers)
        table.horizontalHeader().setDefaultAlignment(Qt.AlignCenter)

        header = table.horizontalHeader()
        font = header.font()
        font.setBold(True)
        header.setFont(font)

        
        # Appearance settings
        table.verticalHeader().setDefaultSectionSize(50)
        
        # Dynamic column width calculation
        worker_col_width = 70
        time_block_col_width = 100
        table_total_width = 700  # match your self.optimized_table width
        
        fixed_width = worker_col_width + (time_block_col_width * num_blocks)
        remaining_width = max(100, table_total_width - fixed_width)
        avg_col_index = num_blocks + 1
        
        # Apply widths
        table.setColumnWidth(0, worker_col_width)  # Worker
        for col in range(1, num_blocks + 1):
            table.setColumnWidth(col, time_block_col_width)  # Time blocks
        table.setColumnWidth(avg_col_index, remaining_width)  # Stretch Avg column to use the rest


        # Fill table
        for row_idx, worker_id in enumerate(worker_ids):
            jobs, risks, avg = optimized_result[worker_id]
    
            # Worker column
            worker_item = QTableWidgetItem(worker_id)
            worker_item.setTextAlignment(Qt.AlignCenter)
            table.setItem(row_idx, 0, worker_item)
    
            # Job assignments
            for b, job_id in enumerate(jobs):
                job = job_info.get(job_id, {})
                risk_val = job.get("prob", 0.0)
                color = job.get("color", "#ffffff")
    
                item = QTableWidgetItem(f"{job_id}\n{risk_val:.1f}%")
                item.setTextAlignment(Qt.AlignCenter)
                item.setBackground(QColor(color))

                item.setToolTip(f"{job.get('tool', '')} – {job.get('name', '')} ({job.get('damage', '')})")
                table.setItem(row_idx, b + 1, item)
    
            # Average column
            avg_item = QTableWidgetItem(f"{avg:.1f}%")
            avg_item.setTextAlignment(Qt.AlignCenter)
    
            # Average color
            colors = [QColor(job_info.get(j, {}).get("color", "#ffffff")) for j in jobs]
            if colors:
                r = sum(c.red() for c in colors) // len(colors)
                g = sum(c.green() for c in colors) // len(colors)
                b = sum(c.blue() for c in colors) // len(colors)
                avg_item.setBackground(QColor(r, g, b))
    
            table.setItem(row_idx, num_blocks + 1, avg_item)



    def clearOptimizedTable(self):
        """
        Clears all contents, rows, and columns from the optimized rotation table.
        """
        table = self.optimized_table
        table.clearContents()
        table.setRowCount(0)
        table.setColumnCount(0)
        table.setHorizontalHeaderLabels([])




    def transferOptimizedToCurrent(self):
        """
        Copies the contents of the optimized_table into the rotation_table,
        recalculates averages, and re-triggers formatting and suggestions.
        """
        source_table = self.optimized_table
        target_table = self.rotation_table
    
        n_rows = source_table.rowCount()
        n_cols = source_table.columnCount()
    
        if n_rows == 0 or n_cols < 3:  # Expect at least Worker + 1 Block + Avg
            QMessageBox.warning(self, "No Data", "Optimized table is empty. Nothing to copy.")
            return
    
        # Resize target table to match optimized table
        target_table.blockSignals(True)
        target_table.clear()
        target_table.setRowCount(n_rows)
        target_table.setColumnCount(n_cols + 1)  # One extra for Suggestion column
    
        #headers = ["Worker"] + [
        #    source_table.horizontalHeaderItem(c).text() for c in range(1, n_cols - 1)
        #] + ["Avg.", "Suggestion"]
        
        headers = ["Worker"] + [
            source_table.horizontalHeaderItem(c).text() for c in range(1, n_cols - 1)
        ] + ["Avg.", "Recommendation"]
        
        target_table.setHorizontalHeaderLabels(headers)


       
        # Appearance setup
        target_table.verticalHeader().setDefaultSectionSize(60)
        worker_col_width = 80
        time_block_col_width = 100
        avg_col_width = 100
        suggestion_col_width = max(150, 950 - (worker_col_width + time_block_col_width * (n_cols - 2) + avg_col_width))
    
        target_table.setColumnWidth(0, worker_col_width)
        for col in range(1, n_cols - 1):
            target_table.setColumnWidth(col, time_block_col_width)
        target_table.setColumnWidth(n_cols - 1, avg_col_width)
        target_table.setColumnWidth(n_cols, suggestion_col_width)
    
        # Copy content from optimized table
        for row in range(n_rows):
            # Worker
            worker_item = source_table.item(row, 0)
            new_worker_item = QTableWidgetItem(worker_item.text() if worker_item else "")
            new_worker_item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            new_worker_item.setToolTip(worker_item.toolTip() if worker_item else "")
            target_table.setItem(row, 0, new_worker_item)

            probs = []
            colors = []
    
            for col in range(1, n_cols - 1):  # Copy time-block jobs
                src_item = source_table.item(row, col)
                if not src_item:
                    continue
                job_id = src_item.text().split("\n")[0].strip()
                try:
                    risk = float(src_item.text().split("\n")[1].replace("%", "").strip())
                except:
                    risk = 0.0

                new_item = QTableWidgetItem(src_item.text())
                new_item.setTextAlignment(Qt.AlignCenter)
                new_item.setBackground(src_item.background())
                new_item.setToolTip(src_item.toolTip())
                target_table.setItem(row, col, new_item)
    
                probs.append(risk)
                bg = src_item.background().color()
                colors.append((bg.red(), bg.green(), bg.blue()))

            # Avg cell
            if probs:
                avg_val = round(sum(probs) / len(probs), 1)
                avg_item = QTableWidgetItem(f"{avg_val}%")
                avg_item.setTextAlignment(Qt.AlignCenter)
                if colors:
                    r = sum(c[0] for c in colors) // len(colors)
                    g = sum(c[1] for c in colors) // len(colors)
                    b = sum(c[2] for c in colors) // len(colors)
                    avg_item.setBackground(QColor(r, g, b))
                target_table.setItem(row, n_cols - 1, avg_item)
    
                # Suggestion
                suggestion_item = QTableWidgetItem(self.generateSuggestion(probs))
                suggestion_item.setTextAlignment(Qt.AlignLeft)
                target_table.setItem(row, n_cols, suggestion_item)
    
        target_table.blockSignals(False)
        target_table.cellChanged.connect(self.handleCellChanged)





    def onCompareClicked(self):
        current_tool = self.tool_combo.currentText()
        all_tools = ["LiFFT", "DUET", "ST"]
        other_tools = [t for t in all_tools if t != current_tool]
    
        # Extract current rotation layout
        worker_ids, job_list, current_assignments, _ = self.extract_rotation_data(
            table=self.rotation_table,
            get_job_risks_func=self.getJobsWithMeasurement,
            tool_id=current_tool
        )
    
        # Optimized assignment (jobs only)
        if self.optimized_table.rowCount() == 0:
            QMessageBox.information(self, "No Optimized Data", "Please optimize a rotation first.")
            return

        # Reconstruct the optimized job assignment structure
        optimized_jobs = {}
        for row in range(self.optimized_table.rowCount()):
            worker_id = self.optimized_table.item(row, 0).text()
            optimized_jobs[worker_id] = []
            for col in range(1, self.optimized_table.columnCount() - 1):
                item = self.optimized_table.item(row, col)
                if item:
                    job_id = item.text().split("\n")[0].strip()
                    optimized_jobs[worker_id].append(job_id)
    
        self.compare_window = CompareRotationWindow(
            current_assignments=current_assignments,
            optimized_assignments=optimized_jobs,
            worker_ids=worker_ids,
            timeblocks=self.timeblocks_combo.currentText(),
            get_jobs_func=self.getJobsWithMeasurement,
            tool_selected=current_tool,
            tools_to_compare=other_tools,
            parent=self
        )
        self.compare_window.show()



    def handleMultiToolOptimizationDone(self, result):
        self.overlay.stop()
    
        optimized_schedule = result["optimized"]
        current_assignments = result["current"]
        worker_ids = result["worker_ids"]
        tool_risk = result["tool_risk"]
        all_tools = list(tool_risk.keys())
    
        # Console print for debug
        def print_schedule(title, schedule, tool_risk):
            print(f"\n=== {title} ===")
            for tool in tool_risk:
                print(f"\n[{tool}]")
                for w in sorted(schedule):
                    risks = [tool_risk[tool].get(j, 0.0) for j in schedule[w]]
                    avg = round(sum(risks) / len(risks), 1) if risks else 0.0
                    jobs_str = " ".join(f"{j}@{tool_risk[tool].get(j, 0.0):04.1f}" for j in schedule[w])
                    print(f"{w}: {jobs_str} -> Avg: {avg:.1f}%")

        
        #TODO: Multi-Op debug prints!!
        print_schedule("Original Average Risk per Worker", current_assignments, tool_risk)
        print_schedule("Optimized Average Risk per Worker", optimized_schedule, tool_risk)
    
        print("\n=== Optimization Completed ===\n")
    
        self.compare_all_window = CompareOpAllRotationWindow(
            current_assignments=current_assignments,
            optimized_assignments=optimized_schedule,
            worker_ids=worker_ids,
            timeblocks=self.timeblocks_combo.currentText(),
            get_jobs_func=self.getJobsWithMeasurement,
            tools=all_tools,
            parent=self
        )
        self.compare_all_window.show()



    def onOptimizeAllClicked(self):
       # print("\n=== Multi-Objective Optimization for All Tools ===")
    
        # Show overlay
        self.overlay = Overlay(parent=self, message="Optimizing Rotation for All Tools") #Overlay(parent=self)
        #self.overlay.label.setText("Optimizing all tools")
        self.overlay.setCancelHandler(self.cancelOptimization)
        seconds = self.getTimeLimitInSeconds(for_multitool=True, solver_name="highs") #TODO: Trick, use other solver but just for the progress bar to considere the full time since with glpk for multi-op I passing half as time-limit to complete both steps in the total time, if I use glpk time the progress bar will finish in half time...
        self.overlay.start(duration_seconds=seconds)
        
        #self.overlay.start()
    
        num_blocks = int(self.timeblocks_combo.currentText())
        all_tools = ["LiFFT", "DUET", "ST"]
    
        # Setup thread and worker
        self.optimizeall_thread = QtCore.QThread()
        self.optimizeall_worker = MultiToolOptimizationWorker(
            table=self.rotation_table,
            num_blocks=num_blocks,
            all_tools=all_tools
        )
    
        self.optimizeall_worker.moveToThread(self.optimizeall_thread)
        self.optimizeall_thread.started.connect(self.optimizeall_worker.run)
        self.optimizeall_worker.optimizationCompleted.connect(self.handleMultiToolOptimizationDone)
        self.optimizeall_worker.optimizationCompleted.connect(self.optimizeall_thread.quit)
        self.optimizeall_worker.optimizationCompleted.connect(self.optimizeall_worker.deleteLater)
        self.optimizeall_thread.finished.connect(self.optimizeall_thread.deleteLater)
    
        self.optimizeall_thread.start()




    def onOptimizeAllClickedWorkingNoThread(self):
        print("\n=== Multi-Objective Optimization for All Tools ===")

        table = self.rotation_table
        num_blocks = int(self.timeblocks_combo.currentText())
        all_tools = ["LiFFT", "DUET", "ST"]
    
        # Step 1: Extract data structure
        worker_ids, _, current_assignments, _ = self.extract_rotation_data(
            table=table,
            get_job_risks_func=self.getJobsWithMeasurement,
            tool_id=all_tools[0]
        )

        # Restrict job list to only those used in current assignment
        job_set = set(j for jobs in current_assignments.values() for j in jobs if j)
        job_list = sorted(job_set)



    
        # Step 2: Get job risk per tool
        tool_risk = {
            tool: {j["id"]: j["probability_outcome"] for j in self.getJobsWithMeasurement(tool)}
            for tool in all_tools
        }

        
        def average_risk(schedule, tool_risk):
            return {
                t: {
                    w: round(sum(tool_risk[t].get(j, 0.0) for j in jobs) / num_blocks, 1)
                    for w, jobs in schedule.items()
                }
                for t in tool_risk
            }

        def annotated(job_list, risk_map):
            """'Job-01@12.5 Job-02@03.5 …'  (width 4, one decimal, leading zeros)."""
            return " ".join(f"{j}@{risk_map.get(j, 0.0):04.1f}" for j in job_list)

        
        def print_schedule(title, schedule, tool_risk):
            """
            Example line:
            V001: Job-01@12.5 Job-02@03.5 Job-03@48.0 Job-04@00.7 -> Avg: 16.2%
            """
            print(f"\n=== {title} ===")
            avgs = average_risk(schedule, tool_risk)
        
            for tool, risk_map in tool_risk.items():      # <-- now risk_map is defined
                print(f"\n[{tool}]")
                for w in sorted(schedule):
                    jobs_str = annotated(schedule[w], risk_map)
                    print(f"{w}: {jobs_str} -> Avg: {avgs[tool][w]:.1f}%")
                    
    
                          
        print_schedule("Original Average Risk per Worker", current_assignments, tool_risk)

        # Step 3: Run multi-objective optimizer
        
        optimized_schedule = self.optimise_multi_tool(
            worker_ids=worker_ids,
            job_list=job_list,
            num_blocks=num_blocks,
            tool_risk=tool_risk,
            solver_name="glpk",  # or "glpk", "cbc", "highs", etc.
            time_limit=self.getTimeLimitInSeconds(for_multitool=True, solver_name="glpk"),
            mip_gap=0.01,
            verbose=True
        )

        
        # Step 4: Print results
        
        print_schedule("Original Average Risk per Worker", current_assignments, tool_risk)
        print_schedule("Optimized Average Risk per Worker", optimized_schedule, tool_risk)
    
        print("\n=== Optimization Completed ===\n")

        self.compare_all_window = CompareOpAllRotationWindow(
            current_assignments=current_assignments,
            optimized_assignments=optimized_schedule,
            worker_ids=worker_ids,
            timeblocks=self.timeblocks_combo.currentText(),
            get_jobs_func=self.getJobsWithMeasurement,
            tools=all_tools,
            parent=self
        )
        self.compare_all_window.show()







    def optimise_multi_tool(self,  
        worker_ids, job_list, num_blocks, tool_risk,
        solver_name="glpk", time_limit=None, mip_gap=None, verbose=True
    ):
        """
        Two-stage MILP with *per-tool* fairness.
    
        Stage 1  minimise  Σ_t g_max[t]       (lowest possible worst average
                                                 inside each tool)
        Stage 2  minimise  Σ_t (g_max[t]−g_min[t])
                   subject to the g_max from Stage 1
        """
        import time
        from typing import Dict, List
        from pyomo.environ import (
            ConcreteModel, Set, Var, Binary, Constraint,
            Objective, minimize, SolverFactory, value
        )

        # ---------- helper: configure solver ----------------------------------
        def _make_solver(name):
            s = SolverFactory(name)

            # -- time limit -----------------------------------------------------
            if time_limit is not None:
                if name == "glpk":
                    s.options["tmlim"] = time_limit
                elif name == "cbc":
                    s.options["seconds"] = time_limit
                elif name.startswith("gurobi"):
                    s.options["TimeLimit"] = time_limit
                elif name.startswith("highs"):
                    s.options["time_limit"] = time_limit
        
            # -- relative MIP gap ----------------------------------------------
            if mip_gap is not None:
                if name == "glpk":
                    s.options["mipgap"] = mip_gap
                elif name == "cbc":
                    s.options["ratio"] = mip_gap
                elif name.startswith("gurobi"):
                    s.options["MIPGap"] = mip_gap
                elif name.startswith("highs"):
                    s.options["mip_rel_gap"] = mip_gap
        
            # -- suppress HiGHS banner / trace on Windows ----------------------
            #if name.startswith("highs"):
            #    s.options["log_to_console"] = "off"   # prevent WinError 1
        
            return s
    
    

        t0 = time.time()
        if verbose:
            print("\n[OPT] Building MILP model …")
    
        # ---------- model skeleton --------------------------------------------
        m = ConcreteModel("PerToolFairness")
        m.W = Set(initialize=list(worker_ids))
        m.B = Set(initialize=range(num_blocks))
        m.J = Set(initialize=list(job_list))
        m.T = Set(initialize=list(tool_risk))
    
        m.x = Var(m.W, m.B, m.J, domain=Binary)
    
        # assignment constraints ------------------------------------------------
        m.one_job_per_worker_block = Constraint(
            m.W, m.B, rule=lambda md, w, b: sum(md.x[w, b, j] for j in md.J) == 1
        )
        m.one_worker_per_job_block = Constraint(
            m.B, m.J, rule=lambda md, b, j: sum(md.x[w, b, j] for w in md.W) <= 1
        )
        m.unique_job_per_worker = Constraint(
            m.W, m.J, rule=lambda md, w, j: sum(md.x[w, b, j] for b in md.B) <= 1
        )

        # average risk per worker-tool -----------------------------------------
        inv_blocks = 1.0 / num_blocks
        m.avgRisk = Var(m.W, m.T)
        m.avgRisk_def = Constraint(
            m.W, m.T,
            rule=lambda md, w, t: md.avgRisk[w, t] ==
            inv_blocks * sum(md.x[w, b, j] * tool_risk[t].get(j, 0.0)
                             for b in md.B for j in md.J)
        )
    
        # per-tool upper / lower bounds ----------------------------------------
        m.g_max = Var(m.T)                          # worst avg in tool t
        m.g_min = Var(m.T)                          # best  avg in tool t
        m.upper_tool = Constraint(
            m.W, m.T, rule=lambda md, w, t: md.avgRisk[w, t] <= md.g_max[t]
        )
        m.lower_tool = Constraint(
            m.W, m.T, rule=lambda md, w, t: md.avgRisk[w, t] >= md.g_min[t]
        )

        # objectives ------------------------------------------------------------
        m.o1 = Objective(expr=sum(m.g_max[t] for t in m.T), sense=minimize)
        m.o2 = Objective(expr=sum(m.g_max[t] - m.g_min[t] for t in m.T),
                         sense=minimize)
        m.o2.deactivate()
    
        # ---------- stage 1 ----------------------------------------------------
        if verbose:
            print("[OPT] Stage 1 – minimise per-tool ceilings …")
        
        #TODO: Check this tee_flag to avoid optimizer console messages, specially if highs works in windows!!!
        #solver = _make_solver(solver_name)
        #res1 = solver.solve(m, tee=verbose)
        solver = _make_solver(solver_name)
        tee_flag = verbose and not solver_name.startswith("highs")
        tee_flag = True
        res1 = solver.solve(m, tee=tee_flag)          #  no logfile=

        if verbose:
            print("[OPT] Stage 1 done – Σ g_max =", round(sum(value(m.g_max[t]) for t in m.T), 2))

        # ---------- stage 2 ----------------------------------------------------
        # lock in the ceilings we just found
        for t in m.T:
            m.g_max[t].fix(value(m.g_max[t]))
        m.o1.deactivate(); m.o2.activate()
    
        if verbose:
            print("[OPT] Stage 2 – minimise per-tool spreads …")
        #solver = _make_solver(solver_name)
        #res2 = solver.solve(m, tee=verbose)
        #solver = _make_solver(solver_name)
        #tee_flag = verbose and not solver_name.startswith("highs")
        #res2 = solver.solve(m, tee=tee_flag, logfile="highs_stage2.log" if solver_name.startswith("highs") else None)
        solver = _make_solver(solver_name)
        tee_flag = verbose and not solver_name.startswith("highs")
        #tee_flag = False
        res2 = solver.solve(m, tee=tee_flag)          #  no logfile=

        if verbose:
            spread = sum(value(m.g_max[t] - m.g_min[t]) for t in m.T)
            print(f"[OPT] Stage 2 done – total spread = {spread:.2f}")
            print(f"[OPT] Total time: {time.time() - t0:.1f} s")
    
        # ---------- extract schedule ------------------------------------------
        schedule: Dict[str, List[str]] = {w: [""] * num_blocks for w in worker_ids}
        for w in worker_ids:
            for b in m.B:
                for j in job_list:
                    if value(m.x[w, b, j]) > 0.5:
                        schedule[w][b] = j
                        break
        return schedule




    def optimise_multi_toolOldWorking(self,  
        worker_ids, job_list, num_blocks, tool_risk,
        solver_name="glpk", time_limit=None, mip_gap=None, verbose=True
    ):
        """
        Two-stage MILP with *per-tool* fairness.
    
        Stage 1  minimise  Σ_t g_max[t]       (lowest possible worst average
                                                 inside each tool)
        Stage 2  minimise  Σ_t (g_max[t]−g_min[t])
                   subject to the g_max from Stage 1
        """
        import time
        from typing import Dict, List
        from pyomo.environ import (
            ConcreteModel, Set, Var, Binary, Constraint,
            Objective, minimize, SolverFactory, value
        )

        # ---------- helper: configure solver ----------------------------------
        def _make_solver(name):
            s = SolverFactory(name)
            if time_limit is not None:
                 if name == "glpk":
                     s.options["tmlim"] = time_limit
                 elif name == "cbc":
                     s.options["seconds"] = time_limit
                 elif name.startswith("gurobi"):
                     s.options["TimeLimit"] = time_limit
                 elif name.startswith("highs"):
                     s.options["time_limit"] = time_limit
            
            if mip_gap is not None:
                if name == "glpk":
                    s.options["mipgap"] = mip_gap
                elif name == "cbc":
                    s.options["ratio"] = mip_gap
                elif name.startswith("gurobi"):
                    s.options["MIPGap"] = mip_gap
                elif name.startswith("highs"):
                    s.options["mip_rel_gap"] = mip_gap
            
            return s

        t0 = time.time()
        if verbose:
            print("\n[OPT] Building MILP model …")
    
        # ---------- model skeleton --------------------------------------------
        m = ConcreteModel("PerToolFairness")
        m.W = Set(initialize=list(worker_ids))
        m.B = Set(initialize=range(num_blocks))
        m.J = Set(initialize=list(job_list))
        m.T = Set(initialize=list(tool_risk))
    
        m.x = Var(m.W, m.B, m.J, domain=Binary)
    
        # assignment constraints ------------------------------------------------
        m.one_job_per_worker_block = Constraint(
            m.W, m.B, rule=lambda md, w, b: sum(md.x[w, b, j] for j in md.J) == 1
        )
        m.one_worker_per_job_block = Constraint(
            m.B, m.J, rule=lambda md, b, j: sum(md.x[w, b, j] for w in md.W) <= 1
        )
        m.unique_job_per_worker = Constraint(
            m.W, m.J, rule=lambda md, w, j: sum(md.x[w, b, j] for b in md.B) <= 1
        )

        # average risk per worker-tool -----------------------------------------
        inv_blocks = 1.0 / num_blocks
        m.avgRisk = Var(m.W, m.T)
        m.avgRisk_def = Constraint(
            m.W, m.T,
            rule=lambda md, w, t: md.avgRisk[w, t] ==
            inv_blocks * sum(md.x[w, b, j] * tool_risk[t].get(j, 0.0)
                             for b in md.B for j in md.J)
        )
    
        # per-tool upper / lower bounds ----------------------------------------
        m.g_max = Var(m.T)                          # worst avg in tool t
        m.g_min = Var(m.T)                          # best  avg in tool t
        m.upper_tool = Constraint(
            m.W, m.T, rule=lambda md, w, t: md.avgRisk[w, t] <= md.g_max[t]
        )
        m.lower_tool = Constraint(
            m.W, m.T, rule=lambda md, w, t: md.avgRisk[w, t] >= md.g_min[t]
        )

        # objectives ------------------------------------------------------------
        m.o1 = Objective(expr=sum(m.g_max[t] for t in m.T), sense=minimize)
        m.o2 = Objective(expr=sum(m.g_max[t] - m.g_min[t] for t in m.T),
                         sense=minimize)
        m.o2.deactivate()
    
        # ---------- stage 1 ----------------------------------------------------
        if verbose:
            print("[OPT] Stage 1 – minimise per-tool ceilings …")
        solver = _make_solver(solver_name)
        res1 = solver.solve(m, tee=verbose)
        if verbose:
            print("[OPT] Stage 1 done – Σ g_max =", round(sum(value(m.g_max[t]) for t in m.T), 2))

        # ---------- stage 2 ----------------------------------------------------
        # lock in the ceilings we just found
        for t in m.T:
            m.g_max[t].fix(value(m.g_max[t]))
        m.o1.deactivate(); m.o2.activate()
    
        if verbose:
            print("[OPT] Stage 2 – minimise per-tool spreads …")
        solver = _make_solver(solver_name)
        res2 = solver.solve(m, tee=verbose)
        if verbose:
            spread = sum(value(m.g_max[t] - m.g_min[t]) for t in m.T)
            print(f"[OPT] Stage 2 done – total spread = {spread:.2f}")
            print(f"[OPT] Total time: {time.time() - t0:.1f} s")
    
        # ---------- extract schedule ------------------------------------------
        schedule: Dict[str, List[str]] = {w: [""] * num_blocks for w in worker_ids}
        for w in worker_ids:
            for b in m.B:
                for j in job_list:
                    if value(m.x[w, b, j]) > 0.5:
                        schedule[w][b] = j
                        break
        return schedule




    #def cancelOptimization(self):
    #    print("[CANCEL] Optimization was manually cancelled.")
    #    if hasattr(self, "optimization_thread"):
    #        #self.optimization_thread.terminate()  # Warning: this is unsafe unless worker is well-controlled
    #        self.optimization_thread.request_cancel() 
    #        self.optimization_thread.wait()

    def cancelOptimization(self):
        print("[CANCEL] Optimization was manually cancelled.")

        if hasattr(self, "optimizer_worker"):
            self.optimizer_worker.request_cancel()  # Correct target
        if hasattr(self, "optimizer_worker_all"):
            self.optimizer_worker_all.request_cancel()  # For multi-tool optimizer
    
        if hasattr(self, "overlay"):
            self.overlay.stop()
    
        # You can optionally wait for the thread to finish safely
        if hasattr(self, "optimization_thread"):
            self.optimization_thread.quit()
            self.optimization_thread.wait()
        if hasattr(self, "optimization_thread_all"):
            self.optimization_thread_all.quit()
            self.optimization_thread_all.wait()


    def getTimeLimitInSeconds(self, for_multitool=False, solver_name="glpk"):
        try:
            minutes = int(self.time_limit_input.text())
            seconds = minutes * 60
            # Divide by 2 only for multi-tool with glpk
            if for_multitool and solver_name.lower() == "glpk":
                return seconds // 2
            return seconds
        except ValueError:
            return 60  # Default to 1 minute











class OptimizationWorker(QtCore.QObject):
    optimizationCompleted = QtCore.pyqtSignal(dict)

    def __init__(self, table, tool_id, num_blocks, parent=None):
        super().__init__(parent)
        self.table = table
        self.tool_id = tool_id
        self.num_blocks = num_blocks
        self.cancel_requested = False

    def request_cancel(self):
        self.cancel_requested = True
        
    def run(self):
        from pulp import PULP_CBC_CMD
        parent = QtWidgets.QApplication.instance().activeWindow()

        worker_ids, job_list, current_assignments, job_risk = parent.extract_rotation_data(
            self.table, parent.getJobsWithMeasurement, self.tool_id
        )

        model, x = parent.build_optimization_model(
            worker_ids, job_list, current_assignments, job_risk, self.num_blocks
        )

        time_limit = parent.getTimeLimitInSeconds()
        model.solve(PULP_CBC_CMD(msg=0, timeLimit=time_limit))
        
        
        
        if self.cancel_requested:
            print("[CANCELLED] Optimization was cancelled before result emitted.")
            return
        
        result = parent.extract_solution(model, x, worker_ids, job_risk, self.num_blocks)
        self.optimizationCompleted.emit(result)




class Overlay(QWidget):
    def __init__(self, parent=None, message="Optimizing Rotation"):
        super().__init__(parent)
        self.setGeometry(parent.geometry())
        self.setStyleSheet("background-color: rgba(0, 0, 0, 100);")

        self.base_message = message

        # Animated Label
        self.label = QLabel(message, self)
        self.label.setStyleSheet("color: white; font-size: 16pt; font-weight: bold;")
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setGeometry(self.width() // 2 - 200, self.height() // 2 - 60, 400, 50)

        # Progress Bar (fills over 5 minutes)
        self.progress = QProgressBar(self)
        self.progress.setGeometry(self.width() // 2 - 150, self.height() // 2, 300, 20)
        self.progress.setValue(0)
        self.progress.setStyleSheet("""
            QProgressBar {
                border: 2px solid grey;
                border-radius: 5px;
                text-align: center;
                background-color: white;
            }
            QProgressBar::chunk {
                background-color: #72ff00;
                width: 1px;
            }
        """)

        # Optional Cancel Button
        # self.cancel_button = QPushButton("Cancel", self)
        # self.cancel_button.setStyleSheet("background-color: red; color: white; font-weight: bold;")
        # self.cancel_button.setGeometry(self.width() // 2 - 50, self.height() // 2 + 40, 100, 30)
        # self.cancel_button.clicked.connect(self._onCancelClicked)

        self._cancel_handler = None  # Optional external callback

        self.timer = QTimer(self)
        self.timer.timeout.connect(self.animateText)
        self.dot_count = 0

        self.progress_timer = QTimer(self)
        self.progress_timer.timeout.connect(self.updateProgress)
        self.progress_elapsed = 0
        #self.progress_duration = 360  # 5 minutes (300 seconds)

    #def start(self):
    #    self.show()
    #    self.raise_()
    #    self.dot_count = 0
    #    self.progress_elapsed = 0
    #    self.progress.setValue(0)
    #    self.timer.start(500)
    #    self.progress_timer.start(1000)
        
    def start(self, duration_seconds=300):
        self.show()
        self.raise_()
        self.dot_count = 0
        self.progress_elapsed = 0
        self.progress.setValue(0)
        self.progress_duration = duration_seconds
        self.timer.start(500)
        self.progress_timer.start(1000)
    

    def stop(self):
        self.hide()
        self.timer.stop()
        self.progress_timer.stop()
        self.progress.setValue(0)

    def animateText(self):
        dots = "." * (self.dot_count % 4)
        self.label.setText(f"{self.base_message}{dots}")
        self.dot_count += 1

    def updateProgress(self):
        self.progress_elapsed += 1
        percent = int((self.progress_elapsed / self.progress_duration) * 100)
        self.progress.setValue(min(percent, 100))

    def setCancelHandler(self, callback):
        self._cancel_handler = callback

    def _onCancelClicked(self):
        if self._cancel_handler:
            self._cancel_handler()
        self.stop()



    


class OverlayWithOnlyCancel(QtWidgets.QWidget):
    def __init__(self, parent=None, message="Optimizing Rotation"):
        super().__init__(parent)
        self.setGeometry(parent.geometry())
        self.setStyleSheet("background-color: rgba(0, 0, 0, 100);")

        self.label = QLabel(message, self)
        self.label.setStyleSheet("color: white; font-size: 16pt; font-weight: bold;")
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setGeometry(self.width() // 2 - 200, self.height() // 2 - 60, 400, 50)

        # Cancel Button
        self.cancel_button = QPushButton("Cancel", self)
        self.cancel_button.setStyleSheet("background-color: red; color: white; font-weight: bold;")
        self.cancel_button.setGeometry(self.width() // 2 - 50, self.height() // 2 + 10, 100, 30)
        self.cancel_button.clicked.connect(self._onCancelClicked)
        self._cancel_handler = None  # settable callback

        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(self.animateText)
        self.dot_count = 0
        self.base_message = message

    def start(self):
        self.show()
        self.raise_()
        self.dot_count = 0
        self.timer.start(500)

    def stop(self):
        self.hide()
        self.timer.stop()

    def animateText(self):
        dots = "." * (self.dot_count % 4)
        self.label.setText(f"{self.base_message}{dots}")
        self.dot_count += 1

    def setCancelHandler(self, callback):
        """
        Set a function to call when the Cancel button is clicked.
        """
        self._cancel_handler = callback

    def _onCancelClicked(self):
        if self._cancel_handler:
            self._cancel_handler()
        self.stop()




class OverlayOldWorking(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setGeometry(parent.geometry())
        self.setStyleSheet("background-color: rgba(0, 0, 0, 100);")

        self.label = QLabel("Optimizing rotation", self)
        self.label.setStyleSheet("color: white; font-size: 16pt; font-weight: bold;")
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setGeometry(self.width() // 2 - 150, self.height() // 2 - 25, 300, 50)

        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(self.animateText)
        self.dot_count = 0

    def start(self):
        self.show()
        self.raise_()
        self.dot_count = 0
        self.timer.start(500)

    def stop(self):
        self.hide()
        self.timer.stop()

    def animateText(self):
        dots = "." * (self.dot_count % 4)
        self.label.setText(f"Optimizing rotation{dots}")
        self.dot_count += 1







    




class MultiToolOptimizationWorker(QtCore.QObject):
    optimizationCompleted = QtCore.pyqtSignal(dict)

    def __init__(self, table, num_blocks, all_tools, parent=None):
        super().__init__(parent)
        self.table = table
        self.num_blocks = num_blocks
        self.all_tools = all_tools
        self.cancel_requested = False

    def request_cancel(self):
        self.cancel_requested = True
        
    
    def run(self):
        parent = QtWidgets.QApplication.instance().activeWindow()

        worker_ids, _, current_assignments, _ = parent.extract_rotation_data(
            table=self.table,
            get_job_risks_func=parent.getJobsWithMeasurement,
            tool_id=self.all_tools[0]
        )

        # Restrict to used jobs only
        job_set = set(j for jobs in current_assignments.values() for j in jobs if j)
        job_list = sorted(job_set)

        tool_risk = {
            tool: {j["id"]: j["probability_outcome"] for j in parent.getJobsWithMeasurement(tool)}
            for tool in self.all_tools
        }

        optimized_schedule = parent.optimise_multi_tool(
            worker_ids=worker_ids,
            job_list=job_list,
            num_blocks=self.num_blocks,
            tool_risk=tool_risk,
            solver_name="highs",  # or "glpk", "cbc", "highs", etc.
            time_limit=parent.getTimeLimitInSeconds(for_multitool=True, solver_name="highs"),
            mip_gap=0.01,
            verbose=True
        )


        if self.cancel_requested:
            print("[CANCELLED] Multi-tool optimization was cancelled.")
            return
            
        self.optimizationCompleted.emit({
            "optimized": optimized_schedule,
            "current": current_assignments,
            "worker_ids": worker_ids,
            "tool_risk": tool_risk
        })


















if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = RotationLayoutWindow()
    window.show()
    sys.exit(app.exec_())

 


